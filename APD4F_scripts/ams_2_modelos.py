import math
import os
import time
import pickle
import cv2
import darknet
import numpy as np



#To normalize the mlp data (All predictors-training dataset - 28 predictors)
#APDM
u = np.array([9.09106623e+02, 1.05738223e+00, 4.01556492e+02, 4.15881999e+02,
              3.15145035e+02, 3.00285205e+02, 4.87967948e+02, 5.31478794e+02,
              3.87211508e-01, 3.15303209e+02, 3.59825385e+02, 2.92086914e+02,
              3.39647453e+02, 3.38519504e+02, 3.80003317e+02, 3.83417641e-01,
              9.68300700e+02, 2.15281262e+03, 2.31289485e+02, 1.56180841e-01,
              6.82105596e-02, 5.53272210e-04, 1.58077774e-04, 1.58631046e-01,
              5.61650332e-01, 2.06291495e-02, 5.29560544e-03, 2.86911160e-02])

#MLP10_ams (MLP =79.18% + GBC=71.67%)
"""u2 = np.array([8.58077614e+02, 8.80006495e-01, 3.92791498e+02, 3.82533416e+02,
                 3.05569658e+02, 2.46252891e+02, 4.80013338e+02, 5.18813941e+02,
                 2.98820091e-01, 3.10563874e+02, 3.12559376e+02, 2.87194013e+02,
                 2.93020701e+02, 3.33933735e+02, 3.32098050e+02, 4.18705347e-01,
                 9.27689235e+02, 2.02464734e+03, 2.31970764e+02, 1.23240961e-01,
                 7.43667460e-02, 2.70621347e-04, 1.08248539e-04, 2.24182724e-01,
                 5.41026196e-01, 1.41264343e-02, 3.73457458e-03, 1.89434943e-02])"""

#MLP8_ams (MLP =79.18% + RFC=85.44%)
"""u2 = np.array([8.59853112e+02, 8.80246980e-01, 3.93099740e+02, 3.82412786e+02,
                 3.05841375e+02, 2.46141187e+02, 4.80358105e+02, 5.18684385e+02,
                 2.99030493e-01, 3.10622080e+02, 3.12410656e+02, 2.87259574e+02,
                 2.92872541e+02, 3.33984585e+02, 3.31948771e+02, 4.19758436e-01,
                 9.27397412e+02, 2.02297112e+03, 2.32075899e+02, 1.23273574e-01,
                 7.30108866e-02, 2.70811894e-04, 1.08324758e-04, 2.25315496e-01,
                 5.41407139e-01, 1.41905432e-02, 3.79136652e-03, 1.86318583e-02])"""

#MLP9_ams (MLP=79.18% + NB=72.77%)
"""u2 = np.array([8.59077622e+02, 8.79621622e-01, 3.92849841e+02, 3.82387132e+02,
             3.05633419e+02, 2.46089290e+02, 4.80066263e+02, 5.18684975e+02,
             2.98432432e-01, 3.10635637e+02, 3.12353736e+02, 2.87279103e+02,
             2.92822454e+02, 3.33992172e+02, 3.31885018e+02, 4.18918919e-01,
             9.26670113e+02, 2.02166737e+03, 2.31840859e+02, 1.23243243e-01,
             7.45405405e-02, 2.70270270e-04, 1.08108108e-04, 2.24864865e-01,
             5.40324324e-01, 1.41621622e-02, 3.78378378e-03, 1.87027027e-02])"""

#MLP11_ams (MLP =79.18% + LR=75.11%)
"""u2 = np.array([8.58077614e+02, 8.80006495e-01, 3.92791498e+02, 3.82533416e+02,
             3.05569658e+02, 2.46252891e+02, 4.80013338e+02, 5.18813941e+02,
             2.98820091e-01, 3.10563874e+02, 3.12559376e+02, 2.87194013e+02,
             2.93020701e+02, 3.33933735e+02, 3.32098050e+02, 4.18705347e-01,
             9.27689235e+02, 2.02464734e+03, 2.31970764e+02, 1.23240961e-01,
             7.43667460e-02, 2.70621347e-04, 1.08248539e-04, 2.24182724e-01,
             5.41026196e-01, 1.41264343e-02, 3.73457458e-03, 1.89434943e-02])"""

#MLP12_ams (MLP =79.18% + SVM=76.05%)
"""u2 = np.array([8.59798234e+02, 8.80240494e-01, 3.93102559e+02, 3.82411389e+02,
             3.05846217e+02, 2.46139494e+02, 4.80358901e+02, 5.18683283e+02,
             2.99046690e-01, 3.10616438e+02, 3.12410896e+02, 2.87253787e+02,
             2.92873459e+02, 3.33979089e+02, 3.31948332e+02, 4.19727007e-01,
             9.27307239e+02, 2.02293700e+03, 2.32081730e+02, 1.23280251e-01,
             7.30148413e-02, 2.70826563e-04, 1.08330625e-04, 2.25327700e-01,
             5.41436464e-01, 1.41371466e-02, 3.79157188e-03, 1.86328675e-02])"""

#MLP13_ams (RFC =79.18% + SVM=76.05%)
"""u2 = np.array([8.55903899e+02, 8.83435933e-01, 3.89929273e+02, 3.82198064e+02,
             3.03508454e+02, 2.46115199e+02, 4.76350091e+02, 5.18280928e+02,
             2.94744642e-01, 3.04695345e+02, 3.11905472e+02, 2.81557956e+02,
             2.92624884e+02, 3.27832734e+02, 3.31186061e+02, 4.02302782e-01,
             8.51946248e+02, 1.96427034e+03, 2.38237073e+02, 1.10693114e-01,
             7.17054264e-02, 2.84997720e-04, 1.13999088e-04, 2.18536252e-01,
             5.66233470e-01, 1.47628819e-02, 3.53397173e-03, 1.41358869e-02])"""

#MLP14_ams (RFC =79.18% + LR=75.11%)
"""u2 = np.array([8.57514785e+02, 8.83189021e-01, 3.91349093e+02, 3.82307758e+02,
             3.04060927e+02, 2.45922220e+02, 4.78637259e+02, 5.18693297e+02,
             2.96247890e-01, 3.09326797e+02, 3.11945032e+02, 2.85958738e+02,
             2.92406039e+02, 3.32694855e+02, 3.31484024e+02, 4.23950335e-01,
             9.35140355e+02, 2.02633976e+03, 2.32620927e+02, 1.20078419e-01,
             7.47154604e-02, 2.17829331e-04, 5.44573327e-05, 2.27141535e-01,
             5.40979143e-01, 1.41044492e-02, 3.81201329e-03, 1.88966944e-02])"""

#MLP15_ams (RFC=85.44% + NB=72.77%)
"""u2= np.array([8.54468887e+02, 8.73728476e-01, 3.91147693e+02, 3.81839730e+02,
             3.04806678e+02, 2.45526782e+02, 4.77488709e+02, 5.18152679e+02,
             2.88912883e-01, 3.05227659e+02, 3.11927308e+02, 2.82133965e+02,
             2.92680814e+02, 3.28321353e+02, 3.31173803e+02, 3.93532989e-01,
             8.39142091e+02, 1.95754804e+03, 2.38001812e+02, 1.17520032e-01,
             7.38762289e-02, 2.84139342e-04, 1.13655737e-04, 2.17878047e-01,
             5.64528045e-01, 7.33079502e-03, 3.52332784e-03, 1.49457294e-02])
"""
#MLP16_ams (RFC=85.44% + GBC=71.67%)
u2 = np.array([8.60762292e+02, 8.79655228e-01, 3.93161312e+02, 3.82498977e+02,
             3.05759356e+02, 2.46173151e+02, 4.80563268e+02, 5.18824803e+02,
             2.99398276e-01, 3.10692183e+02, 3.12578882e+02, 2.87292550e+02,
             2.93009305e+02, 3.34091816e+02, 3.32148459e+02, 4.19038326e-01,
             9.32664492e+02, 2.03117379e+03, 2.32243763e+02, 1.23326286e-01,
             7.30742126e-02, 3.25256139e-04, 1.08418713e-04, 2.25727761e-01,
             5.42147775e-01, 1.42028514e-02, 3.79465496e-03, 1.72927847e-02])

#MLP17_ams (SVM=76.05% + GBC=71.67%)
"""u2 = np.array([8.54000225e+02, 8.81192583e-01, 3.91159741e+02, 3.82244618e+02,
             3.04750706e+02, 2.46156816e+02, 4.77568776e+02, 5.18332420e+02,
             2.96962182e-01, 3.07010569e+02, 3.12111503e+02, 2.83819865e+02,
             2.92796519e+02, 3.30201272e+02, 3.31426488e+02, 4.00552330e-01,
             8.55707192e+02, 1.97381626e+03, 2.36855558e+02, 1.13509553e-01,
             7.26483684e-02, 2.81801274e-04, 1.12720509e-04, 2.18057826e-01,
             5.59882771e-01, 1.46536662e-02, 3.71977681e-03, 1.71335174e-02])"""

#MLP18_ams (LR=75.11% + GBC=71.67%)
"""u2 = np.array([8.59320295e+02, 8.79401885e-01, 3.92880314e+02, 3.82580094e+02,
             3.05538725e+02, 2.46254877e+02, 4.80221903e+02, 5.18905310e+02,
             2.99219850e-01, 3.10609467e+02, 3.12671984e+02, 2.87214552e+02,
             2.93106478e+02, 3.34004381e+02, 3.32237489e+02, 4.18030122e-01,
             9.31619618e+02, 2.03039723e+03, 2.32142414e+02, 1.23361144e-01,
             7.42767364e-02, 3.25062304e-04, 1.08354101e-04, 2.24834760e-01,
             5.41824683e-01, 1.41943873e-02, 3.79239354e-03, 1.72824791e-02])"""

#MLP19_ams (SVM=76.05% + LR=75.11%)
"""u2 = np.array([8.53844098e+02, 8.83838098e-01, 3.90349376e+02, 3.82347133e+02,
             3.03894376e+02, 2.46323737e+02, 4.76804376e+02, 5.18370529e+02,
             2.94820266e-01, 3.06082071e+02, 3.12179878e+02, 2.82907240e+02,
             2.92889767e+02, 3.29256902e+02, 3.31469990e+02, 4.02037928e-01,
             8.54438183e+02, 1.97042326e+03, 2.37359281e+02, 1.11633173e-01,
             7.27993207e-02, 2.83045570e-04, 1.13218228e-04, 2.19020662e-01,
             5.62354939e-01, 1.37560147e-02, 3.73620153e-03, 1.63034249e-02])"""

#MLP20_ams (SVM=76.05% + NB=72.77%)
"""u2 = np.array([8.54705099e+02, 8.82445938e-01, 3.90838595e+02, 3.82502557e+02,
             3.04576037e+02, 2.46691700e+02, 4.77101154e+02, 5.18313415e+02,
             2.95691943e-01, 3.06056495e+02, 3.12550162e+02, 2.82968004e+02,
             2.93312917e+02, 3.29144987e+02, 3.31787408e+02, 3.96533228e-01,
             8.38942379e+02, 1.95167301e+03, 2.36963420e+02, 1.15747276e-01,
             7.34007114e-02, 2.82310429e-04, 1.12924171e-04, 2.16475637e-01,
             5.60894359e-01, 1.46801423e-02, 3.50064931e-03, 1.49059906e-02])"""

#MLP21_ams (SVM=76.05% + GBC=71.67%)
"""u2 = np.array([8.60762292e+02, 8.79655228e-01, 3.93161312e+02, 3.82498977e+02,
             3.05759356e+02, 2.46173151e+02, 4.80563268e+02, 5.18824803e+02,
             2.99398276e-01, 3.10692183e+02, 3.12578882e+02, 2.87292550e+02,
             2.93009305e+02, 3.34091816e+02, 3.32148459e+02, 4.19038326e-01,
             9.32664492e+02, 2.03117379e+03, 2.32243763e+02, 1.23326286e-01,
             7.30742126e-02, 3.25256139e-04, 1.08418713e-04, 2.25727761e-01,
             5.42147775e-01, 1.42028514e-02, 3.79465496e-03, 1.72927847e-02])"""

#MLP30_ams (RFC3 + RFC4)
"""u2 = np.array([8.54129171e+02, 8.70658886e-01, 3.91220380e+02, 3.81464639e+02,
             3.04377082e+02, 2.44653205e+02, 4.78063679e+02, 5.18276073e+02,
             2.88312277e-01, 3.05786380e+02, 3.11513945e+02, 2.82542331e+02,
             2.92132084e+02, 3.29030429e+02, 3.30895806e+02, 3.97484562e-01,
             8.69083259e+02, 1.99445169e+03, 2.37938990e+02, 1.17273809e-01,
             7.31403320e-02, 3.96578098e-04, 1.13308028e-04, 2.18457878e-01,
             5.62800974e-01, 7.30836780e-03, 3.34258682e-03, 1.71661662e-02])"""

#MLP31_ams (RFC3 + RFC5)
"""u2 = np.array([8.55129038e+02, 8.75486827e-01, 3.89579767e+02, 3.81681214e+02,
             3.03175929e+02, 2.45193234e+02, 4.75983605e+02, 5.18169194e+02,
             2.87227950e-01, 3.03460356e+02, 3.11429053e+02, 2.80339576e+02,
             2.92154586e+02, 3.26581136e+02, 3.30703520e+02, 3.97938144e-01,
             8.50895332e+02, 1.96615962e+03, 2.38971581e+02, 1.11225659e-01,
             7.35967927e-02, 2.29095074e-04, 5.72737686e-05, 2.20962199e-01,
             5.68957617e-01, 7.27376861e-03, 3.55097365e-03, 1.41466208e-02])"""

#MLP32_ams (RFC3 + RFC11)
"""u2 = np.array([8.58039987e+02, 8.84021603e-01, 3.91803698e+02, 3.82217586e+02,
             3.04418654e+02, 2.45780752e+02, 4.79188743e+02, 5.18654420e+02,
             2.98347062e-01, 3.09474820e+02, 3.11902462e+02, 2.86077467e+02,
             2.92335401e+02, 3.32872173e+02, 3.31469523e+02, 4.24799520e-01,
             9.37793345e+02, 2.03171123e+03, 2.32896708e+02, 1.20233484e-01,
             7.31002128e-02, 2.18209590e-04, 1.09104795e-04, 2.27538050e-01,
             5.41923518e-01, 1.41290710e-02, 3.81866783e-03, 1.89296820e-02])"""

#MLP32_ams (RFC3 + RFC11)_refined
"""u2 = np.array([8.58826192e+02, 8.78792778e-01, 3.92896355e+02, 3.82295469e+02,
             3.05610088e+02, 2.45917421e+02, 4.80182622e+02, 5.18673517e+02,
             2.97655618e-01, 3.11106080e+02, 3.12251617e+02, 2.87731467e+02,
             2.92705688e+02, 3.34480693e+02, 3.31797546e+02, 4.19671248e-01,
             9.30982559e+02, 2.02657296e+03, 2.31668285e+02, 1.23309081e-01,
             7.44812719e-02, 3.77256804e-04, 1.07787658e-04, 2.24791161e-01,
             5.39477230e-01, 1.41201832e-02, 3.77256804e-03, 1.95634600e-02])"""

#MLP32_ams (RFC3 + RFC11)_balanced
"""u2 = np.array([8.72738583e+02, 8.67591657e-01, 3.74291512e+02, 3.78768355e+02,
             2.84262152e+02, 2.38997726e+02, 4.64320872e+02, 5.18538985e+02,
             2.89993568e-01, 3.07199282e+02, 3.04310678e+02, 2.83416948e+02,
             2.84433272e+02, 3.30981616e+02, 3.24188085e+02, 4.74593403e-01,
             1.05246686e+03, 2.11576498e+03, 2.18587297e+02, 1.67600845e-01,
             1.02545254e-01, 2.75659285e-04, 1.83772857e-04, 2.13360287e-01,
             4.79279610e-01, 1.11182578e-02, 4.41054856e-03, 2.12257650e-02])"""

#MLP32_ams (RFC3 + RFC11)_refined2
"""u2 = np.array([8.54460348e+02, 8.76117350e-01, 3.90588151e+02, 3.81751434e+02,
             3.04197104e+02, 2.45388829e+02, 4.76979198e+02, 5.18114040e+02,
             2.89078616e-01, 3.04207125e+02, 3.11664515e+02, 2.81098692e+02,
             2.92405132e+02, 3.27315558e+02, 3.30923897e+02, 3.96802659e-01,
             8.41585521e+02, 1.96055412e+03, 2.39031500e+02, 1.13683245e-01,
             7.20834288e-02, 2.29200092e-04, 1.14600046e-04, 2.19688288e-01,
             5.69218428e-01, 7.27710291e-03, 3.55260142e-03, 1.41531057e-02])"""

#MLP32_ams (RFC3 + RFC11)_distance
"""u2 = np.array([8.58826192e+02, 8.78792778e-01, 3.92896355e+02, 3.82295469e+02,
             3.05610088e+02, 2.45917421e+02, 4.80182622e+02, 5.18673517e+02,
             2.97655618e-01, 3.11106080e+02, 3.12251617e+02, 2.87731467e+02,
             2.92705688e+02, 3.34480693e+02, 3.31797546e+02, 4.19671248e-01,
             9.30982559e+02, 2.02657296e+03, 2.31668285e+02, 1.23309081e-01,
             7.44812719e-02, 3.77256804e-04, 1.07787658e-04, 2.24791161e-01,
             5.39477230e-01, 1.41201832e-02, 3.77256804e-03, 1.95634600e-02])"""

#MLP32_ams (RFC3 + RFC11)_distance_2
"""u2 = np.array([8.58826192e+02, 8.78792778e-01, 3.92896355e+02, 3.82295469e+02,
             3.05610088e+02, 2.45917421e+02, 4.80182622e+02, 5.18673517e+02,
             2.97655618e-01, 3.11106080e+02, 3.12251617e+02, 2.87731467e+02,
             2.92705688e+02, 3.34480693e+02, 3.31797546e+02, 4.19671248e-01,
             9.30982559e+02, 2.02657296e+03, 2.31668285e+02, 1.23309081e-01,
             7.44812719e-02, 3.77256804e-04, 1.07787658e-04, 2.24791161e-01,
             5.39477230e-01, 1.41201832e-02, 3.77256804e-03, 1.95634600e-02])"""

#MLP(MLP+GBC)_distance
"""u2 = np.array([8.58826192e+02, 8.78792778e-01, 3.92896355e+02, 3.82295469e+02,
             3.05610088e+02, 2.45917421e+02, 4.80182622e+02, 5.18673517e+02,
             2.97655618e-01, 3.11106080e+02, 3.12251617e+02, 2.87731467e+02,
             2.92705688e+02, 3.34480693e+02, 3.31797546e+02, 4.19671248e-01,
             9.30982559e+02, 2.02657296e+03, 2.31668285e+02, 1.23309081e-01,
             7.44812719e-02, 3.77256804e-04, 1.07787658e-04, 2.24791161e-01,
             5.39477230e-01, 1.41201832e-02, 3.77256804e-03, 1.95634600e-02])"""

#MLP(MLP+LR)_distance
"""u2 = np.array([8.58826192e+02, 8.78792778e-01, 3.92896355e+02, 3.82295469e+02,
             3.05610088e+02, 2.45917421e+02, 4.80182622e+02, 5.18673517e+02,
             2.97655618e-01, 3.11106080e+02, 3.12251617e+02, 2.87731467e+02,
             2.92705688e+02, 3.34480693e+02, 3.31797546e+02, 4.19671248e-01,
             9.30982559e+02, 2.02657296e+03, 2.31668285e+02, 1.23309081e-01,
             7.44812719e-02, 3.77256804e-04, 1.07787658e-04, 2.24791161e-01,
             5.39477230e-01, 1.41201832e-02, 3.77256804e-03, 1.95634600e-02])"""

#MLP(MLP+NB)_distance
"""u2 = np.array([8.58826192e+02, 8.78792778e-01, 3.92896355e+02, 3.82295469e+02,
             3.05610088e+02, 2.45917421e+02, 4.80182622e+02, 5.18673517e+02,
             2.97655618e-01, 3.11106080e+02, 3.12251617e+02, 2.87731467e+02,
             2.92705688e+02, 3.34480693e+02, 3.31797546e+02, 4.19671248e-01,
             9.30982559e+02, 2.02657296e+03, 2.31668285e+02, 1.23309081e-01,
             7.44812719e-02, 3.77256804e-04, 1.07787658e-04, 2.24791161e-01,
             5.39477230e-01, 1.41201832e-02, 3.77256804e-03, 1.95634600e-02])"""

#MLP(MLP+SVM)_distance
"""u2 = np.array([8.58826192e+02, 8.78792778e-01, 3.92896355e+02, 3.82295469e+02,
             3.05610088e+02, 2.45917421e+02, 4.80182622e+02, 5.18673517e+02,
             2.97655618e-01, 3.11106080e+02, 3.12251617e+02, 2.87731467e+02,
             2.92705688e+02, 3.34480693e+02, 3.31797546e+02, 4.19671248e-01,
             9.30982559e+02, 2.02657296e+03, 2.31668285e+02, 1.23309081e-01,
             7.44812719e-02, 3.77256804e-04, 1.07787658e-04, 2.24791161e-01,
             5.39477230e-01, 1.41201832e-02, 3.77256804e-03, 1.95634600e-02])"""

#MLP(MLP+KNN)_distance
"""u2 = np.array([8.58826192e+02, 8.78792778e-01, 3.92896355e+02, 3.82295469e+02,
             3.05610088e+02, 2.45917421e+02, 4.80182622e+02, 5.18673517e+02,
             2.97655618e-01, 3.11106080e+02, 3.12251617e+02, 2.87731467e+02,
             2.92705688e+02, 3.34480693e+02, 3.31797546e+02, 4.19671248e-01,
             9.30982559e+02, 2.02657296e+03, 2.31668285e+02, 1.23309081e-01,
             7.44812719e-02, 3.77256804e-04, 1.07787658e-04, 2.24791161e-01,
             5.39477230e-01, 1.41201832e-02, 3.77256804e-03, 1.95634600e-02])"""

#APDM
s = np.array([4.43693600e+02, 9.50245842e-01, 2.16075512e+02, 4.92883235e+01,
              2.16727143e+02, 8.71466305e+01, 2.25161619e+02, 2.14580602e+01,
              6.72153476e-01, 1.68249783e+02, 7.25382729e+01, 1.65957845e+02,
              7.71079606e+01, 1.71079386e+02, 6.88302982e+01, 4.86218627e-01,
              1.90893059e+03, 2.14921043e+03, 1.47367328e+02, 3.63026701e-01,
              2.52106880e-01, 2.35152312e-02, 1.25719046e-02, 3.65331682e-01,
              4.96184680e-01, 1.42139325e-01, 7.25779719e-02, 1.66936922e-01])

#MLP10_ams (MLP =79.18% + GBC=71.67%)
"""s2 = np.array([4.60524491e+02, 8.74173423e-01, 2.12234363e+02, 6.87397305e+01,
             2.19984096e+02, 1.11843273e+02, 2.12687277e+02, 3.91170674e+01,
             6.00984897e-01, 1.52852279e+02, 9.71516257e+01, 1.52137021e+02,
             9.90954815e+01, 1.54058414e+02, 9.57782278e+01, 4.93346916e-01,
             1.66477361e+03, 1.81211294e+03, 1.37516715e+02, 3.28713594e-01,
             2.62366791e-01, 1.64483467e-02, 1.04036927e-02, 4.17042959e-01,
             4.98314009e-01, 1.18012195e-01, 6.09969469e-02, 1.36325487e-01])"""

#MLP8_ams (MLP =79.18% + RFC=85.44%)
"""s2 = np.array([4.60662088e+02, 8.74086243e-01, 2.12286845e+02, 6.88579007e+01,
                 2.20039580e+02, 1.11927398e+02, 2.12729975e+02, 3.92582504e+01,
                 6.01144112e-01, 1.52927569e+02, 9.72948205e+01, 1.52227439e+02,
                 9.92282433e+01, 1.54116716e+02, 9.59297255e+01, 4.93519292e-01,
                 1.66284209e+03, 1.80722287e+03, 1.37507191e+02, 3.28750970e-01,
                 2.60154372e-01, 1.64541349e-02, 1.04073543e-02, 4.17789927e-01,
                 4.98282499e-01, 1.18275829e-01, 6.14572376e-02, 1.35220975e-01])"""

#MLP9_ams (MLP=79.18% + NB=72.77%)
"""s2 = np.array([4.61142797e+02, 8.73851906e-01, 2.12177984e+02, 6.88316378e+01,
             2.19893417e+02, 1.11871884e+02, 2.12655814e+02, 3.92564193e+01,
             6.00691248e-01, 1.52810090e+02, 9.72639968e+01, 1.52110667e+02,
             9.91954833e+01, 1.53998229e+02, 9.59006505e+01, 4.93382061e-01,
             1.66130404e+03, 1.80606356e+03, 1.37474258e+02, 3.28716209e-01,
             2.62648526e-01, 1.64376770e-02, 1.03969429e-02, 4.17493302e-01,
             4.98371296e-01, 1.18159195e-01, 6.13959833e-02, 1.35472918e-01])"""

#MLP11_ams (MLP =79.18% + LR=75.11%)
"""s2 = np.array([4.60524491e+02, 8.74173423e-01, 2.12234363e+02, 6.87397305e+01,
             2.19984096e+02, 1.11843273e+02, 2.12687277e+02, 3.91170674e+01,
             6.00984897e-01, 1.52852279e+02, 9.71516257e+01, 1.52137021e+02,
             9.90954815e+01, 1.54058414e+02, 9.57782278e+01, 4.93346916e-01,
             1.66477361e+03, 1.81211294e+03, 1.37516715e+02, 3.28713594e-01,
             2.62366791e-01, 1.64483467e-02, 1.04036927e-02, 4.17042959e-01,
             4.98314009e-01, 1.18012195e-01, 6.09969469e-02, 1.36325487e-01])"""

#MLP12_ams (MLP =79.18% + SVM=76.05%)
"""s2 = np.array([4.60614212e+02, 8.74109471e-01, 2.12292249e+02, 6.88595037e+01,
             2.20044556e+02, 1.11930192e+02, 2.12735709e+02, 3.92590281e+01,
             6.01156363e-01, 1.52929789e+02, 9.72974500e+01, 1.52229531e+02,
             9.92308523e+01, 1.54119080e+02, 9.59323050e+01, 4.93514181e-01,
             1.66284199e+03, 1.80726587e+03, 1.37508632e+02, 3.28758621e-01,
             2.60160862e-01, 1.64545804e-02, 1.04076361e-02, 4.17797951e-01,
             4.98280061e-01, 1.18056290e-01, 6.14588957e-02, 1.35224568e-01])"""

#MLP13_ams (RFC =79.18% + SVM=76.05%)
"""s2 = np.array([4.66031075e+02, 8.74690567e-01, 2.14478378e+02, 6.92687398e+01,
             2.22781342e+02, 1.12184008e+02, 2.14205235e+02, 3.96508195e+01,
             5.97955718e-01, 1.51618599e+02, 9.76452203e+01, 1.51113455e+02,
             9.94064652e+01, 1.52594807e+02, 9.64054386e+01, 4.90362370e-01,
             1.58423969e+03, 1.72463232e+03, 1.38014604e+02, 3.13751731e-01,
             2.57999531e-01, 1.68794697e-02, 1.06764269e-02, 4.13253141e-01,
             4.95593712e-01, 1.20602401e-01, 5.93420826e-02, 1.18051106e-01])"""

#MLP14_ams (RFC =79.18% + LR=75.11%)
"""s2 = np.array([4.61781986e+02, 8.74354632e-01, 2.12057490e+02, 6.89951904e+01,
             2.19930954e+02, 1.12238496e+02, 2.12439195e+02, 3.92847175e+01,
             5.99170381e-01, 1.52436797e+02, 9.72758893e+01, 1.51723196e+02,
             9.92588441e+01, 1.53645006e+02, 9.58654372e+01, 4.94182606e-01,
             1.67385927e+03, 1.82123768e+03, 1.37678167e+02, 3.25053214e-01,
             2.62931665e-01, 1.47574348e-02, 7.37932023e-03, 4.18984794e-01,
             4.98317880e-01, 1.17921642e-01, 6.16237117e-02, 1.36160234e-01])"""

#MLP15_ams (RFC=85.44% + NB=72.77%)
"""s2 = np.array([4.67286904e+02, 8.71770163e-01, 2.15174269e+02, 6.91319193e+01,
             2.23348038e+02, 1.11910442e+02, 2.15002196e+02, 3.96732960e+01,
             5.90657065e-01, 1.51943452e+02, 9.78295527e+01, 1.51473742e+02,
             9.95791753e+01, 1.52883774e+02, 9.65998022e+01, 4.88533290e-01,
             1.57649163e+03, 1.72388559e+03, 1.37859189e+02, 3.22038932e-01,
             2.61569363e-01, 1.68540383e-02, 1.06603386e-02, 4.12804074e-01,
             4.95818648e-01, 8.53056532e-02, 5.92529662e-02, 1.21335710e-01])"""

#MLP16_ams (RFC=85.44% + GBC=71.67%)
s2 = np.array([4.60408156e+02, 8.74793987e-01, 2.12394744e+02, 6.88398006e+01,
             2.20183283e+02, 1.12014201e+02, 2.12834959e+02, 3.91717772e+01,
             6.01376392e-01, 1.53208307e+02, 9.72465311e+01, 1.52464326e+02,
             9.92141547e+01, 1.54444948e+02, 9.58511636e+01, 4.93401669e-01,
             1.67163262e+03, 1.81971903e+03, 1.37488281e+02, 3.28811364e-01,
             2.60258280e-01, 1.80319258e-02, 1.04118662e-02, 4.18060688e-01,
             4.98220398e-01, 1.18326372e-01, 6.14837828e-02, 1.30360057e-01])

#MLP17_ams (SVM=76.05% + GBC=71.67%)
"""s2 = np.array([4.65326695e+02, 8.74905619e-01, 2.14148719e+02, 6.90740893e+01,
             2.22388827e+02, 1.11845073e+02, 2.13905787e+02, 3.95736831e+01,
             6.00132726e-01, 1.52367162e+02, 9.75026018e+01, 1.51777716e+02,
             9.92289016e+01, 1.53431725e+02, 9.62996830e+01, 4.90010368e-01,
             1.57416399e+03, 1.73669929e+03, 1.37895180e+02, 3.17214650e-01,
             2.59558438e-01, 1.67845721e-02, 1.06163932e-02, 4.12926883e-01,
             4.96401102e-01, 1.20162125e-01, 6.08764328e-02, 1.29768872e-01])"""

#MLP18_ams (LR=75.11% + GBC=71.67%)
"""s2 = np.array([4.60426493e+02, 8.74741223e-01, 2.12377607e+02, 6.87579976e+01,
         2.20151662e+02, 1.11928603e+02, 2.12828978e+02, 3.91023792e+01,
         6.01241572e-01, 1.53150026e+02, 9.71423202e+01, 1.52406225e+02,
         9.91118671e+01, 1.54386548e+02, 9.57454908e+01, 4.93235176e-01,
         1.67110808e+03, 1.81940454e+03, 1.37502086e+02, 3.28851292e-01,
         2.62220714e-01, 1.80265537e-02, 1.04087636e-02, 4.17473461e-01,
         4.98247625e-01, 1.18291617e-01, 6.14655293e-02, 1.30321890e-01])"""

#MLP19_ams (SVM=76.05% + LR=75.11%)
"""s2 = np.array([4.65955612e+02, 8.75480888e-01, 2.13803280e+02, 6.91860878e+01,
         2.22240211e+02, 1.12070496e+02, 2.13390113e+02, 3.95894822e+01,
         5.98260336e-01, 1.51857901e+02, 9.75635291e+01, 1.51301376e+02,
         9.93223247e+01, 1.52891559e+02, 9.63265863e+01, 4.90309527e-01,
         1.57706291e+03, 1.73796070e+03, 1.37986427e+02, 3.14914604e-01,
         2.59806812e-01, 1.68215771e-02, 1.06398031e-02, 4.13582654e-01,
         4.96096625e-01, 1.16476550e-01, 6.10101822e-02, 1.26639738e-01])"""

#MLP20_ams (SVM=76.05% + NB=72.77%)
"""s2 = np.array([4.65715689e+02, 8.74201684e-01, 2.14405345e+02, 6.90445510e+01,
         2.22618760e+02, 1.11659825e+02, 2.14135084e+02, 3.95943500e+01,
         5.98893324e-01, 1.52050434e+02, 9.75348056e+01, 1.51575313e+02,
         9.92059184e+01, 1.52988600e+02, 9.63739507e+01, 4.89177501e-01,
         1.55659705e+03, 1.69925103e+03, 1.37984168e+02, 3.19921621e-01,
         2.60793111e-01, 1.67997241e-02, 1.06259785e-02, 4.11842124e-01,
         4.96278024e-01, 1.20269014e-01, 5.90626343e-02, 1.21176739e-01])"""

#MLP21_ams (SVM=76.05% + GBC=71.67%)
"""s2 = np.array([4.60408156e+02, 8.74793987e-01, 2.12394744e+02, 6.88398006e+01,
         2.20183283e+02, 1.12014201e+02, 2.12834959e+02, 3.91717772e+01,
         6.01376392e-01, 1.53208307e+02, 9.72465311e+01, 1.52464326e+02,
         9.92141547e+01, 1.54444948e+02, 9.58511636e+01, 4.93401669e-01,
         1.67163262e+03, 1.81971903e+03, 1.37488281e+02, 3.28811364e-01,
         2.60258280e-01, 1.80319258e-02, 1.04118662e-02, 4.18060688e-01,
         4.98220398e-01, 1.18326372e-01, 6.14837828e-02, 1.30360057e-01])"""

#MLP30_ams (RFC3 + RFC4)
"""s2 = np.array([4.67355949e+02, 8.71420801e-01, 2.14812011e+02, 6.91851256e+01,
         2.22962521e+02, 1.12333089e+02, 2.14849397e+02, 3.95931457e+01,
         5.90454292e-01, 1.52104767e+02, 9.78162004e+01, 1.51474468e+02,
         9.96865968e+01, 1.53226013e+02, 9.64931370e+01, 4.89377753e-01,
         1.62899741e+03, 1.79141119e+03, 1.37608440e+02, 3.21746271e-01,
         2.60366710e-01, 1.99103195e-02, 1.06440213e-02, 4.13199750e-01,
         4.96040359e-01, 8.51760269e-02, 5.77184021e-02, 1.29890296e-01])"""

"""#MLP31_ams (RFC3 + RFC5)
s2 = np.array([4.68102990e+02, 8.72492590e-01, 2.15138141e+02, 6.93125195e+01,
         2.23394545e+02, 1.12340115e+02, 2.14989159e+02, 3.97137695e+01,
         5.89646827e-01, 1.51288434e+02, 9.78450596e+01, 1.50814901e+02,
         9.96626959e+01, 1.52239167e+02, 9.65570622e+01, 4.89472550e-01,
         1.60976975e+03, 1.74622961e+03, 1.37945487e+02, 3.14411373e-01,
         2.61113586e-01, 1.51341531e-02, 7.56772676e-03, 4.14895054e-01,
         4.95222018e-01, 8.49756489e-02, 5.94841512e-02, 1.18095275e-01])"""

"""#MLP32_ams (RFC3 + RFC11)
s2 = np.array([4.61250383e+02, 8.75023630e-01, 2.12285305e+02, 6.90051000e+01,
             2.20134439e+02, 1.12248929e+02, 2.12686708e+02, 3.93003517e+01,
             6.01461131e-01, 1.52648358e+02, 9.73156184e+01, 1.51905332e+02,
             9.92804477e+01, 1.53885395e+02, 9.59253292e+01, 4.94312541e-01,
             1.67526900e+03, 1.82303694e+03, 1.37644010e+02, 3.25234367e-01,
             2.60300925e-01, 1.47703072e-02, 1.04447542e-02, 4.19242753e-01,
             4.98239319e-01, 1.18023050e-01, 6.16772698e-02, 1.36276737e-01])"""

#MLP32_ams (RFC3 + RFC11)_refined
"""s2 = np.array([4.61264049e+02, 8.73836138e-01, 2.12023059e+02, 6.88305168e+01,
             2.19749117e+02, 1.11909089e+02, 2.12522391e+02, 3.92387913e+01,
             6.00056048e-01, 1.53051667e+02, 9.72844045e+01, 1.52326594e+02,
             9.92280091e+01, 1.54268811e+02, 9.59122833e+01, 4.93505108e-01,
             1.66722908e+03, 1.81643835e+03, 1.37456731e+02, 3.28791654e-01,
             2.62552494e-01, 1.94194357e-02, 1.03815240e-02, 4.17444721e-01,
             4.98439112e-01, 1.17986455e-01, 6.13052671e-02, 1.38494516e-01])"""

"""#MLP32_ams (RFC3 + RFC11)_balanced
s2 = np.array([4.82985527e+02, 8.65385885e-01, 2.10888698e+02, 6.98726081e+01,
             2.15951819e+02, 1.14409829e+02, 2.14702875e+02, 3.99108342e+01,
             5.93602784e-01, 1.51365661e+02, 9.79181397e+01, 1.50118295e+02,
             9.99445027e+01, 1.53152739e+02, 9.65068310e+01, 4.99354088e-01,
             1.76654138e+03, 1.95648725e+03, 1.27405871e+02, 3.73511448e-01,
             3.03364014e-01, 1.66007017e-02, 1.35550391e-02, 4.09679966e-01,
             4.99570481e-01, 1.04855339e-01, 6.62653426e-02, 1.44136157e-01])"""

#MLP32_ams (RFC3 + RFC11)_refined2
"""s2 = np.array([4.67280133e+02, 8.72655029e-01, 2.15351815e+02, 6.92553480e+01,
             2.23651345e+02, 1.12131857e+02, 2.15069882e+02, 3.97315008e+01,
             5.91336645e-01, 1.51695696e+02, 9.78859608e+01, 1.51225211e+02,
             9.96504091e+01, 1.52637644e+02, 9.66429924e+01, 4.89234411e-01,
             1.58210908e+03, 1.72776146e+03, 1.37936002e+02, 3.17426157e-01,
             2.58626000e-01, 1.51376207e-02, 1.07045277e-02, 4.14035438e-01,
             4.95185631e-01, 8.49949803e-02, 5.94977348e-02, 1.18121951e-01])"""

#MLP32_ams (RFC3 + RFC11)_distance
"""s2 = np.array([4.61264049e+02, 8.73836138e-01, 2.12023059e+02, 6.88305168e+01,
             2.19749117e+02, 1.11909089e+02, 2.12522391e+02, 3.92387913e+01,
             6.00056048e-01, 1.53051667e+02, 9.72844045e+01, 1.52326594e+02,
             9.92280091e+01, 1.54268811e+02, 9.59122833e+01, 4.93505108e-01,
             1.66722908e+03, 1.81643835e+03, 1.37456731e+02, 3.28791654e-01,
             2.62552494e-01, 1.94194357e-02, 1.03815240e-02, 4.17444721e-01,
             4.98439112e-01, 1.17986455e-01, 6.13052671e-02, 1.38494516e-01])
"""
#MLP32_ams (RFC3 + RFC11)_distance_2
"""s2 = np.array([4.61264049e+02, 8.73836138e-01, 2.12023059e+02, 6.88305168e+01,
             2.19749117e+02, 1.11909089e+02, 2.12522391e+02, 3.92387913e+01,
             6.00056048e-01, 1.53051667e+02, 9.72844045e+01, 1.52326594e+02,
             9.92280091e+01, 1.54268811e+02, 9.59122833e+01, 4.93505108e-01,
             1.66722908e+03, 1.81643835e+03, 1.37456731e+02, 3.28791654e-01,
             2.62552494e-01, 1.94194357e-02, 1.03815240e-02, 4.17444721e-01,
             4.98439112e-01, 1.17986455e-01, 6.13052671e-02, 1.38494516e-01])"""

#MLP(MLP+GBC)_distance
"""s2 = np.array([4.61264049e+02, 8.73836138e-01, 2.12023059e+02, 6.88305168e+01,
             2.19749117e+02, 1.11909089e+02, 2.12522391e+02, 3.92387913e+01,
             6.00056048e-01, 1.53051667e+02, 9.72844045e+01, 1.52326594e+02,
             9.92280091e+01, 1.54268811e+02, 9.59122833e+01, 4.93505108e-01,
             1.66722908e+03, 1.81643835e+03, 1.37456731e+02, 3.28791654e-01,
             2.62552494e-01, 1.94194357e-02, 1.03815240e-02, 4.17444721e-01,
             4.98439112e-01, 1.17986455e-01, 6.13052671e-02, 1.38494516e-01])"""

#MLP(MLP+LR)_distance
"""s2 = np.array([4.61264049e+02, 8.73836138e-01, 2.12023059e+02, 6.88305168e+01,
             2.19749117e+02, 1.11909089e+02, 2.12522391e+02, 3.92387913e+01,
             6.00056048e-01, 1.53051667e+02, 9.72844045e+01, 1.52326594e+02,
             9.92280091e+01, 1.54268811e+02, 9.59122833e+01, 4.93505108e-01,
             1.66722908e+03, 1.81643835e+03, 1.37456731e+02, 3.28791654e-01,
             2.62552494e-01, 1.94194357e-02, 1.03815240e-02, 4.17444721e-01,
             4.98439112e-01, 1.17986455e-01, 6.13052671e-02, 1.38494516e-01])"""

#MLP(MLP+NB)_distance
"""s2 = np.array([4.61264049e+02, 8.73836138e-01, 2.12023059e+02, 6.88305168e+01,
             2.19749117e+02, 1.11909089e+02, 2.12522391e+02, 3.92387913e+01,
             6.00056048e-01, 1.53051667e+02, 9.72844045e+01, 1.52326594e+02,
             9.92280091e+01, 1.54268811e+02, 9.59122833e+01, 4.93505108e-01,
             1.66722908e+03, 1.81643835e+03, 1.37456731e+02, 3.28791654e-01,
             2.62552494e-01, 1.94194357e-02, 1.03815240e-02, 4.17444721e-01,
             4.98439112e-01, 1.17986455e-01, 6.13052671e-02, 1.38494516e-01])"""

#MLP(MLP+SVM)_distance
"""s2 = np.array([4.61264049e+02, 8.73836138e-01, 2.12023059e+02, 6.88305168e+01,
             2.19749117e+02, 1.11909089e+02, 2.12522391e+02, 3.92387913e+01,
             6.00056048e-01, 1.53051667e+02, 9.72844045e+01, 1.52326594e+02,
             9.92280091e+01, 1.54268811e+02, 9.59122833e+01, 4.93505108e-01,
             1.66722908e+03, 1.81643835e+03, 1.37456731e+02, 3.28791654e-01,
             2.62552494e-01, 1.94194357e-02, 1.03815240e-02, 4.17444721e-01,
             4.98439112e-01, 1.17986455e-01, 6.13052671e-02, 1.38494516e-01])"""

#MLP(MLP+KNN)_distance
"""s2 = np.array([4.61264049e+02, 8.73836138e-01, 2.12023059e+02, 6.88305168e+01,
             2.19749117e+02, 1.11909089e+02, 2.12522391e+02, 3.92387913e+01,
             6.00056048e-01, 1.53051667e+02, 9.72844045e+01, 1.52326594e+02,
             9.92280091e+01, 1.54268811e+02, 9.59122833e+01, 4.93505108e-01,
             1.66722908e+03, 1.81643835e+03, 1.37456731e+02, 3.28791654e-01,
             2.62552494e-01, 1.94194357e-02, 1.03815240e-02, 4.17444721e-01,
             4.98439112e-01, 1.17986455e-01, 6.13052671e-02, 1.38494516e-01])"""

def convertBack(x, y, w, h):
#Converts center coordinates to rectangle coordinates
    xmin = x - (w / 2)
    xmax = x + (w / 2)
    ymin = y - (h / 2)
    ymax = y + (h / 2)
    return xmin, ymin, xmax, ymax



def cvDrawBoxes(detections, img):
    global currentframe
    currentframe += 1
    if len(detections) > 0:
        persons = dict()
        handguns = dict()
        faces = dict()
        perId, hgId, facId = 0,0,0
        for detections in detections:
            name_tag = detections[0]


            if name_tag == 'Person':
                xmid,ymid,w,h = detections[2][0], \
                        detections[2][1], \
                        detections[2][2], \
                        detections[2][3],
                xmin, ymin, xmax, ymax = convertBack(float(xmid),float(ymid),float(w),float(h))
                persons[perId] = (xmid, ymid, xmin, ymin, xmax, ymax)
                perId += 1

            elif name_tag == 'Handgun':
                xmid,ymid,w,h = detections[2][0], \
                        detections[2][1], \
                        detections[2][2], \
                        detections[2][3],
                xmin, ymin, xmax, ymax = convertBack(float(xmid),float(ymid),float(w),float(h))
                handguns[hgId] = (float(xmid), float(ymid), xmin, ymin, xmax, ymax)
                hgId += 1

            elif name_tag == 'Face':
                xmid,ymid,w,h = detections[2][0], \
                        detections[2][1], \
                        detections[2][2], \
                        detections[2][3],
                xmin, ymin, xmax, ymax = convertBack(float(xmid),float(ymid),float(w),float(h))
                faces[facId] = (float(xmid), float(ymid), xmin, ymin, xmax, ymax)
                facId += 1


        archivo = open("./label/results" + "_video_test" + ".txt", "a")

        for nper, per in enumerate(persons.values()):
            per_xmid = per[0]
            per_ymid = per[1]
            per_xmin = per[2]
            per_ymin = per[3]
            per_xmax = per[4]
            per_ymax = per[5]
            for nhg, hg in enumerate(handguns.values()):
                Intersection_Up_center, Intersection_Up_left, Intersection_Up_right, Intersection_Down_left, Intersection_Down_center, \
                Intersection_Down_right, Intersection_Center_right, Intersection_Center_left, Intersection_Center_right, Intersection_Center_left, \
                Intersection_Inside = 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                hg_xmid = hg[0]
                hg_ymid = hg[1]
                hg_xmin = hg[2]
                hg_ymin = hg[3]
                hg_xmax = hg[4]
                hg_ymax = hg[5]
                a2 = hg_xmax - hg_xmin
                b2 = hg_ymax - hg_ymin
                areah = a2 * b2
                areai, ai, bi = 0, 0, 0
                p1 = hg_xmid - per_xmid
                p2 = hg_ymid - per_ymid
                dist = math.sqrt(p1 ** 2 + p2 ** 2)


                if per_xmin < hg_xmid and hg_xmid < per_xmax and per_ymin < hg_ymid and hg_ymid < per_ymax:
                    included_center = 1
                else:
                    included_center = 0

                if hg_xmax < per_xmin or hg_ymax < per_ymin or hg_xmin > per_xmax or hg_ymin > per_ymax:
                    Intersection_No_intersection = 1
                else:
                    Intersection_No_intersection = 0

                    if hg_xmin < per_xmin: #Left side
                        if hg_ymin < per_ymin:          # SI
                            ai = hg_xmax - per_xmin
                            bi = hg_ymax - per_ymin
                            Intersection_Up_left = 1
                        elif hg_ymax > per_ymax:        # II
                            ai = hg_xmax - per_xmin
                            bi = per_ymax - hg_ymin
                            Intersection_Down_left = 1
                        else:                           # CI
                            ai = hg_xmax - per_xmin
                            bi = hg_ymax - hg_ymin
                            Intersection_Center_left = 1


                    elif hg_xmax > per_xmax: #Rigth side
                        if hg_ymin < per_ymin:          # SD
                            ai = per_xmax - hg_xmin
                            bi = hg_ymax - per_ymin
                            Intersection_Up_right = 1
                        elif hg_ymax > per_ymax:        # ID
                            ai = per_xmax - hg_xmin
                            bi = per_ymax - hg_ymin
                            Intersection_Down_rigth = 1
                        else:                           # CD
                            ai = per_xmax - hg_xmin
                            bi = hg_ymax - hg_ymin
                            Intersection_Center_right = 1


                    elif hg_xmin > per_xmin and hg_xmax < per_xmax: #center
                        if hg_ymin < per_ymin:          # SC
                            ai = hg_xmax - hg_xmin
                            bi = hg_ymax - per_ymin
                            Intersection_Up_center = 1
                        elif hg_ymax > per_ymax:        # IC
                            ai = hg_xmax - hg_xmin
                            bi = per_ymax - hg_ymin
                            Intersection_Down_center = 1
                        else:                           # Hg_in_per
                            ai = hg_xmax - hg_xmin
                            bi = hg_ymax - hg_ymin
                            Intersection_Inside = 1

                areai = ai * bi


                predictors_per = [[currentframe, nper, per_xmid, per_ymid, per_xmin, per_ymin, per_xmax, per_ymax, nhg, hg_xmid, hg_ymid, hg_xmin, hg_ymin,
                   hg_xmax, hg_ymax, included_center, areai, areah, dist, Intersection_Center_left, Intersection_Center_right,
                   Intersection_Down_center, Intersection_Down_left, Intersection_Inside, Intersection_No_intersection, Intersection_Up_center,
                   Intersection_Up_left, Intersection_Up_right]]


                print(f'predictor_per {predictors_per}')
                print(f'ci={Intersection_Center_left}, cd={Intersection_Center_right}, ic={Intersection_Down_center}, ii={Intersection_Down_left},'
                      f' hginper={Intersection_Inside}, ni={Intersection_No_intersection}, sc={Intersection_Up_center}, si={Intersection_Up_left},'
                      f' sd={Intersection_Up_right}')


                #For MLP AMS
                predictors_per2 = ((predictors_per - u2)) / s2  # Only for mlp
                predictors_model = np.array(predictors_per2).reshape(1,-1)
                ypredic_model = loaded_model_selection.predict(predictors_model)


                #For RFC AMS
                #predictors_model = np.array(predictors_per).reshape(1,-1)
                #ypredic_model = loaded_model_selection.predict(predictors_model)


                if ypredic_model == 0:
                    modelo = "RFC"
                    #predictors_per = ((predictors_per - u)) / s #Only for mlp, knn and SVM
                    predictors_per = np.array(predictors_per).reshape(1, -1)
                    ypredic_per = loaded_model_per0.predict(predictors_per)
                    print(f"Prediction_person {nper}: {ypredic_per}")
                    probability = loaded_model_per0.predict_proba(predictors_per)
                    prob1 = probability[0, 1]
                    prob0 = probability[0, 0]
                    if ypredic_per == 1:
                        prediction = 1
                        cv2.rectangle(img, (int(per_xmin), int(per_ymin)), (int(per_xmax), int(per_ymax)), (255, 0, 0), 2)
                        for nfac, fac in enumerate(faces.values()):
                            fac_xmid = fac[0]
                            fac_ymid = fac[1]
                            fac_xmin = fac[2]
                            fac_ymin = fac[3]
                            fac_xmax = fac[4]
                            fac_ymax = fac[5]
                            a2 = fac_xmax - fac_xmin
                            b2 = fac_ymax - fac_ymin
                            areaf = a2 * b2
                            areai, ai, bi = 0, 0, 0
                            p1 = fac_xmid - per_xmid
                            p2 = fac_ymid - per_ymid
                            dist = math.sqrt(p1 ** 2 + p2 ** 2)

                            Intersection_Up_center, Intersection_Up_left, Intersection_Up_right, Intersection_Down_left, Intersection_Down_center, \
                            Intersection_Down_right, Intersection_Center_right, Intersection_Center_left, Intersection_Center_right, Intersection_Center_left, \
                            Intersection_Inside = 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

                            if (
                                    per_xmin < fac_xmid and fac_xmid < per_xmax and per_ymin < fac_ymid and fac_ymid < per_ymax):
                                included_center = 1
                            else:
                                included_center = 0

                            if fac_xmax < per_xmin or fac_ymax < per_ymin or fac_xmin > per_xmax or fac_ymin > per_ymax:
                                Intersection_No_intersection = 1
                                continue
                            else:
                                Intersection_No_intersection = 0

                            if fac_xmin >= per_xmin and fac_xmax <= per_xmax and fac_ymin <= per_ymin and fac_ymax >= per_ymin:  # SC
                                ai = fac_xmax - fac_xmin
                                bi = fac_ymax - per_ymin
                                Intersection_Up_center = 1

                            elif fac_xmax >= per_xmin and fac_xmin <= per_xmin and fac_ymax >= per_ymin and fac_ymin <= per_ymin:  # SI
                                ai = fac_xmax - per_xmin
                                bi = fac_ymax - per_ymin
                                Intersection_Up_left = 1

                            elif fac_xmax >= per_xmax and fac_xmin <= per_xmax and fac_ymax >= per_ymin and fac_ymin <= per_ymin:  # SD
                                ai = per_xmax - fac_xmin
                                bi = fac_ymax - per_ymin
                                Intersection_Up_right = 1

                            elif fac_xmax >= per_xmin and fac_xmin <= per_xmin and fac_ymax >= per_ymax and fac_ymin <= per_ymax:  # II
                                ai = fac_xmax - per_xmin
                                bi = per_ymax - fac_ymin
                                Intersection_Down_left = 1

                            elif fac_xmax >= per_xmin and fac_xmin >= per_xmin and fac_ymax >= per_ymax and fac_ymin <= per_ymax:  # IC
                                ai = fac_xmax - fac_xmin
                                bi = per_ymax - fac_ymin
                                Intersection_Down_center = 1

                            elif fac_xmax >= per_xmax and fac_xmin <= per_xmax and fac_ymax >= per_ymax and fac_ymin <= per_ymax:  # ID
                                ai = per_xmax - fac_xmin
                                bi = per_ymax - fac_ymin
                                Intersection_Down_right = 1

                            elif fac_xmax >= per_xmax and fac_xmin <= per_xmax and fac_ymax <= per_ymax and fac_ymin >= per_ymin:  # CD
                                ai = per_xmax - fac_xmin
                                bi = fac_ymax - fac_ymin
                                Intersection_Center_right = 1

                            elif fac_xmax >= per_xmin and fac_xmin <= per_xmin and fac_ymax <= per_ymax and fac_ymin >= per_ymin:  # CI
                                ai = fac_xmax - per_xmin
                                bi = fac_ymax - fac_ymin
                                Intersection_Center_left = 1

                            elif per_xmin < fac_xmid and fac_xmid < per_xmax and per_ymin < fac_ymid and fac_ymid < per_ymax:  # Hg_in_per
                                ai = fac_xmax - fac_xmin
                                bi = fac_ymax - fac_ymin
                                Intersection_Inside = 1

                            areai = ai * bi

                            predictors_fac = [currentframe, per_xmid, per_ymid, per_xmin, per_ymin, per_xmax, per_ymax,
                                              fac_xmid, fac_ymid, fac_xmin, fac_ymin,
                                              fac_xmax, fac_ymax, included_center, areai, areaf, dist,
                                              Intersection_Center_left, Intersection_Center_right,
                                              Intersection_Inside, Intersection_No_intersection, Intersection_Up_center,
                                              Intersection_Up_left,
                                              Intersection_Up_right]

                            #predictors_fac = ((predictors_fac - u)) / s  # Only for mlp

                            predictors_fac = np.array(predictors_fac).reshape(1, -1)  # una fila y el resto de datos indistinto.

                            ypredic_fac = loaded_model_fac.predict(predictors_fac)

                            print(f"Prediction_face {nfac}: {ypredic_fac}")
                            if ypredic_fac == 1:
                                cv2.rectangle(img, (int(fac_xmin), int(fac_ymin)), (int(fac_xmax), int(fac_ymax)),
                                              (255, 0, 0), 2)

                                x = int(fac_xmin)
                                y = int(fac_ymin)
                                h = (int(fac_ymax) - int(fac_ymin))
                                w = (int(fac_xmax) - int(fac_xmin))
                                # print(h,w)
                                cropped_image = img[y:y + h, x:x + w]
                                try:
                                    cv2.imshow("Cropped Image", cropped_image)  # Muestra la img cortada.
                                    cv2.imwrite('./cropped_faces/frame' + str(currentframe) + '.jpg', cropped_image)
                                except:
                                    print(f"Error en frame {currentframe}")

                    else:
                        prediction = 0

                elif ypredic_model == 1:
                    modelo = "GBC"
                    predictors_per = [[currentframe, nper, per_xmid, per_ymid, per_xmin, per_ymin, per_xmax, per_ymax, nhg, hg_xmid, hg_ymid, hg_xmin, hg_ymin,
                   hg_xmax, hg_ymax, included_center, areai, areah, dist, Intersection_Center_left, Intersection_Center_right,
                   Intersection_Down_center, Intersection_Down_left, Intersection_Inside, Intersection_No_intersection, Intersection_Up_center,
                   Intersection_Up_left, Intersection_Up_right]]

                    #predictors_per = ((predictors_per - u)) / s  # # Only for mlp, knn and SVM
                    predictors_per = np.array(predictors_per).reshape(1, -1)
                    ypredic_per = loaded_model_per1.predict(predictors_per)
                    print(f"Prediction_person {nper}: {ypredic_per}")
                    probability = loaded_model_per1.predict_proba(predictors_per)
                    prob1 = probability[0, 1]
                    prob0 = probability[0, 0]
                    if ypredic_per == 1:
                        prediction = 1
                        cv2.rectangle(img, (int(per_xmin), int(per_ymin)), (int(per_xmax), int(per_ymax)), (255, 0, 0), 2)
                        for nfac, fac in enumerate(faces.values()):
                            fac_xmid = fac[0]
                            fac_ymid = fac[1]
                            fac_xmin = fac[2]
                            fac_ymin = fac[3]
                            fac_xmax = fac[4]
                            fac_ymax = fac[5]
                            a2 = fac_xmax - fac_xmin
                            b2 = fac_ymax - fac_ymin
                            areaf = a2 * b2
                            areai, ai, bi = 0, 0, 0
                            p1 = fac_xmid - per_xmid
                            p2 = fac_ymid - per_ymid
                            dist = math.sqrt(p1 ** 2 + p2 ** 2)

                            Intersection_Up_center, Intersection_Up_left, Intersection_Up_right, Intersection_Down_left, Intersection_Down_center, \
                            Intersection_Down_right, Intersection_Center_right, Intersection_Center_left, Intersection_Center_right, Intersection_Center_left, \
                            Intersection_Inside = 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

                            if (per_xmin < fac_xmid and fac_xmid < per_xmax and per_ymin < fac_ymid and fac_ymid < per_ymax):
                                included_center = 1
                            else:
                                included_center = 0

                            if fac_xmax < per_xmin or fac_ymax < per_ymin or fac_xmin > per_xmax or fac_ymin > per_ymax:
                                Intersection_No_intersection = 1
                                continue
                            else:
                                Intersection_No_intersection = 0

                            if  fac_xmin >= per_xmin and fac_xmax <= per_xmax and fac_ymin <= per_ymin and fac_ymax >= per_ymin:  # SC
                                ai = fac_xmax - fac_xmin
                                bi = fac_ymax - per_ymin
                                Intersection_Up_center = 1

                            elif fac_xmax >= per_xmin and fac_xmin <= per_xmin and fac_ymax >= per_ymin and fac_ymin <= per_ymin:  # SI
                                ai = fac_xmax - per_xmin
                                bi = fac_ymax - per_ymin
                                Intersection_Up_left = 1

                            elif fac_xmax >= per_xmax and fac_xmin <= per_xmax and fac_ymax >= per_ymin and fac_ymin <= per_ymin:  # SD
                                ai = per_xmax - fac_xmin
                                bi = fac_ymax - per_ymin
                                Intersection_Up_right = 1

                            elif fac_xmax >= per_xmin and fac_xmin <= per_xmin and fac_ymax >= per_ymax and fac_ymin <= per_ymax:  # II
                                ai = fac_xmax - per_xmin
                                bi = per_ymax - fac_ymin
                                Intersection_Down_left = 1

                            elif fac_xmax >= per_xmin and fac_xmin >= per_xmin and fac_ymax >= per_ymax and fac_ymin <= per_ymax:  # IC
                                ai = fac_xmax - fac_xmin
                                bi = per_ymax - fac_ymin
                                Intersection_Down_center = 1

                            elif fac_xmax >= per_xmax and fac_xmin <= per_xmax and fac_ymax >= per_ymax and fac_ymin <= per_ymax:  # ID
                                ai = per_xmax - fac_xmin
                                bi = per_ymax - fac_ymin
                                Intersection_Down_right = 1

                            elif fac_xmax >= per_xmax and fac_xmin <= per_xmax and fac_ymax <= per_ymax and fac_ymin >= per_ymin:  # CD
                                ai = per_xmax - fac_xmin
                                bi = fac_ymax - fac_ymin
                                Intersection_Center_right = 1

                            elif fac_xmax >= per_xmin and fac_xmin <= per_xmin and fac_ymax <= per_ymax and fac_ymin >= per_ymin:  # CI
                                ai = fac_xmax - per_xmin
                                bi = fac_ymax - fac_ymin
                                Intersection_Center_left = 1

                            elif per_xmin < fac_xmid and fac_xmid < per_xmax and per_ymin < fac_ymid and fac_ymid < per_ymax:  # Hg_in_per
                                ai = fac_xmax - fac_xmin
                                bi = fac_ymax - fac_ymin
                                Intersection_Inside = 1

                            areai = ai * bi


                            predictors_fac = [currentframe, per_xmid, per_ymid, per_xmin, per_ymin, per_xmax, per_ymax, fac_xmid, fac_ymid, fac_xmin, fac_ymin,
                                              fac_xmax, fac_ymax, included_center, areai, areaf, dist, Intersection_Center_left, Intersection_Center_right,
                                              Intersection_Inside, Intersection_No_intersection, Intersection_Up_center, Intersection_Up_left,
                                              Intersection_Up_right]

                            #predictors_fac = ((predictors_fac - u)) / s  # Only for mlp

                            predictors_fac = np.array(predictors_fac).reshape(1,-1) # una fila y el resto de datos indistinto.

                            ypredic_fac = loaded_model_fac.predict(predictors_fac)

                            print(f"Prediction_face {nfac}: {ypredic_fac}")
                            if ypredic_fac == 1:
                                cv2.rectangle(img, (int(fac_xmin), int(fac_ymin)), (int(fac_xmax), int(fac_ymax)), (255, 0, 0), 2)

                                x = int(fac_xmin)
                                y = int(fac_ymin)
                                h = (int(fac_ymax) - int(fac_ymin))
                                w = (int(fac_xmax) - int(fac_xmin))
                                #print(h,w)
                                cropped_image = img[y:y + h, x:x + w]
                                try:
                                    cv2.imshow("Cropped Image", cropped_image)  # Muestra la img cortada.
                                    cv2.imwrite('./cropped_faces/frame' + str(currentframe) + '.jpg', cropped_image)
                                except:
                                    print(f"Error en frame {currentframe}")

                    else:
                        prediction = 0


                archivo.write(f"{currentframe},{nper},{per_xmid},{ypredic_per},{prob0},{prob1},{prediction},{modelo}\n")
        archivo.close()

    return img

netMain = None
metaMain = None
altNames = None
currentframe=-1 #Creamos una variable global q usamos en el contador de cropped faces.

#Automatic model selection
loaded_model_selection = pickle.load(open('./modelos/ams/16/mlp_model_intersection.sav', 'rb'))
#loaded_model_selection = pickle.load(open('./modelos/ams/10/rfc_model_intersection.sav','rb'))

#People detection model
loaded_model_per0 = pickle.load(open('./modelos/hg/modelos_finales/rfc3.sav', 'rb'))
loaded_model_per1 = pickle.load(open('./modelos/hg/modelos_finales/gradboost12.sav', 'rb'))
#loaded_model_per2 = pickle.load(open('./modelos/hg/modelos_finales/svm.sav', 'rb'))
#loaded_model_per3 = pickle.load(open('./modelos/hg/modelos_finales/mlp.sav', 'rb'))
#loaded_model_per4 = pickle.load(open('./modelos/hg/modelos_finales/logreg.sav', 'rb'))

#Faces detection model
#loaded_model_fac = pickle.load(open('./modelos/fac/rfc_t.sav', 'rb'))
loaded_model_fac = pickle.load(open('./modelos/fac/rfc.sav', 'rb'))
#loaded_model_fac = pickle.load(open('./modelos/fac/mlp_t.sav', 'rb'))
#loaded_model_fac = pickle.load(open('./modelos/fac/mlp.sav', 'rb'))

def YOLO():
    """
    Perform Object detection
    """
    global metaMain, netMain, altNames
    configPath = "./cfg/yolov4_2.cfg"
    weightPath = "./backup/yolov4_2_best2.weights"
    metaPath = "./data/custom/piford.data"
    if not os.path.exists(configPath):
        raise ValueError("Invalid config path `" +
                         os.path.abspath(configPath)+"`")
    if not os.path.exists(weightPath):
        raise ValueError("Invalid weight path `" +
                         os.path.abspath(weightPath)+"`")
    if not os.path.exists(metaPath):
        raise ValueError("Invalid data file path `" +
                         os.path.abspath(metaPath)+"`")
    if netMain is None:
        netMain = darknet.load_net_custom(configPath.encode(
            "ascii"), weightPath.encode("ascii"), 0, 1)  # batch size = 1
    if metaMain is None:
        metaMain = darknet.load_meta(metaPath.encode("ascii"))
    if altNames is None:
        try:
            with open(metaPath) as metaFH:
                metaContents = metaFH.read()
                import re
                match = re.search("names *= *(.*)$", metaContents,
                                  re.IGNORECASE | re.MULTILINE)
                if match:
                    result = match.group(1)
                else:
                    result = None
                try:
                    if os.path.exists(result):
                        with open(result) as namesFH:
                            namesList = namesFH.read().strip().split("\n")
                            altNames = [x.strip() for x in namesList]
                except TypeError:
                    pass
        except Exception:
            pass
    #cap = cv2.VideoCapture(0)
    cap = cv2.VideoCapture("./videos_entrada/Test4.mp4")   # <----- Replace with your video directory
    frame_width = int(cap.get(3))
    frame_height = int(cap.get(4))
    new_height, new_width = frame_height // 2, frame_width // 2
    # print("Video Resolution: ",(width, height))

    out = cv2.VideoWriter(
            "./videos_salida/prueba.avi", cv2.VideoWriter_fourcc(*"MJPG"), 10.0, # <----- Replace with your output directory
            (new_width, new_height))
    
    # print("Starting the YOLO loop...")

    # Create an image we reuse for each detect
    darknet_image = darknet.make_image(new_width, new_height, 3)

    frame = 0
    while True:
        frame += 1
        prev_time = time.time()
        ret, frame_read = cap.read()
        # Check if frame present :: 'ret' returns True if frame present, otherwise break the loop.
        if not ret:
            break

        frame_rgb = cv2.cvtColor(frame_read, cv2.COLOR_BGR2RGB)
        frame_resized = cv2.resize(frame_rgb,
                                   (new_width, new_height),
                                   interpolation=cv2.INTER_LINEAR)

        darknet.copy_image_from_bytes(darknet_image,frame_resized.tobytes())

        detections = darknet.detect_image(netMain, namesList, darknet_image, thresh=0.25)
        image = cvDrawBoxes(detections, frame_resized)
        image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
        print("\n")
        print(f"FRAME: {frame}")
        print("FPS: " + str(1/(time.time()-prev_time)))
        cv2.imshow('Demo', image)
        cv2.waitKey(3)
        if cv2.waitKey(1) == ord("q"):
            break
        out.write(image)

    cap.release()
    out.release()
    print(":::Video Write Completed")

if __name__ == "__main__":
    YOLO()